package amyc
package codegen

import analyzer._
import amyc.ast.Identifier
import amyc.ast.SymbolicTreeModule.{Call => AmyCall, Div => AmyDiv, And => AmyAnd, Or => AmyOr, _}
import amyc.utils.{Context, Pipeline}
import wasm._
import Instructions._
import Utils._

// Generates WebAssembly code for an Amy program
object CodeGen extends Pipeline[(Program, SymbolTable), Module] {
  def run(ctx: Context)(v: (Program, SymbolTable)): Module = {
    val (program, table) = v

    // Generate code for an Amy module
    def cgModule(moduleDef: ModuleDef): List[Function] = {
      val ModuleDef(name, defs, optExpr) = moduleDef
      // Generate code for all functions
      defs.collect { case fd: FunDef if !builtInFunctions(fullName(name, fd.name)) =>
        cgFunction(fd, name, false)
      } ++
      // Generate code for the "main" function, which contains the module expression
      optExpr.toList.map { expr =>
        val mainFd = FunDef(Identifier.fresh("main"), Nil, TypeTree(IntType), expr)
        cgFunction(mainFd, name, true)
      }
    }

    // Generate code for a function in module 'owner'
    def cgFunction(fd: FunDef, owner: Identifier, isMain: Boolean): Function = {
      // Note: We create the wasm function name from a combination of
      // module and function name, since we put everything in the same wasm module.
      val name = fullName(owner, fd.name)
      Function(name, fd.params.size, isMain){ lh =>
        val locals = fd.paramNames.zipWithIndex.toMap
        val body = cgExpr(fd.body)(locals, lh)
        val comment = Comment(fd.toString)
        if (isMain) {
          body <:> Drop // Main functions do not return a value,
                        // so we need to drop the value generated by their body
        } else {
          comment <:> body
        }
      }
    }


        // Generate code for an expression expr.
    // Additional arguments are a mapping from identifiers (parameters and variables) to
    // their index in the wasm local variables, and a LocalsHandler which will generate
    // fresh local slots as required.
    def cgExpr(expr: Expr)(implicit locals: Map[Identifier, Int], lh: LocalsHandler): Code = {
      expr match {
        case IntLiteral(i) =>
          // Push i to the stack.
          // The comments are optional but can help you debug.
          // Comment(expr.toString) <:> Const(i)
          Const(i)
        case StringLiteral(i) =>
          // Comment(expr.toString) <:> mkString(i)
          mkString(i)
        case BooleanLiteral(i) =>
          if(i) Const(1)
          else Const(0)
          
        case UnitLiteral() =>
          Const(0)


        case Equals(lhs, rhs) =>
          cgExpr(lhs) <:> cgExpr(rhs) <:> Eq
        case Times(lhs, rhs) =>
          cgExpr(lhs) <:> cgExpr(rhs) <:> Mul
        case Plus(lhs, rhs) =>
          cgExpr(lhs) <:> cgExpr(rhs) <:> Add
        case AmyDiv(lhs, rhs) =>
          cgExpr(lhs) <:> cgExpr(rhs) <:> Div
        case Minus(lhs, rhs) =>
          cgExpr(lhs) <:> cgExpr(rhs) <:> Sub
        case Mod(lhs, rhs) =>
          cgExpr(lhs) <:> cgExpr(rhs) <:> Rem
        case LessThan(lhs, rhs) =>
          cgExpr(lhs) <:> cgExpr(rhs) <:> Lt_s
        case LessEquals(lhs, rhs) =>
          cgExpr(lhs) <:> cgExpr(rhs) <:> Le_s
        case AmyAnd(lhs, rhs) =>
          cgExpr(lhs) <:> If_i32 <:> cgExpr(rhs) <:> Else <:> Const(0) <:> End
        case AmyOr(lhs, rhs) =>
          cgExpr(lhs) <:> If_i32 <:> Const(1) <:> Else <:> cgExpr(rhs) <:> End
        case Concat(lhs, rhs) =>
          cgExpr(lhs) <:> cgExpr(rhs) <:> Call(concatImpl.name)
        case Not(e) =>
          cgExpr(e) <:> Eqz
        case Neg(e) =>
          Const(0) <:> cgExpr(e) <:> Sub

        case Sequence(e1, e2) => cgExpr(e1) <:> Drop <:> cgExpr(e2)

        case Let(df, va, expr) =>
          val local = lh.getFreshLocal()
          cgExpr(va) <:> SetLocal(local) <:> cgExpr(expr)(locals + (df.name -> local), lh)

        case Ite(cond, ifExpr, elseExpr) =>
          cgExpr(cond) <:> If_i32 <:> cgExpr(ifExpr) <:> Else <:> cgExpr(elseExpr) <:> End

        case Variable(e) =>
          GetLocal(locals(e))
        // case AmyCall(qname, args) =>{
        //   table.getConstructor(qname) match{
        //     case Some(sig) =>{
        //       val memoryAddr = lh.getFreshLocal()
        //       ???
        //     }
        //     case None =>{
        //       args.map(arg => cgExpr(arg)) <:> Call(Utils.fullName(table.getFunction(qname).get.owner, qname))
        //     }
        //   }
        // }
        case AmyCall(qname, args) =>{
          table.getConstructor(qname) match{
            case Some(sig) =>{
              val memAddr = lh.getFreshLocal()
              // val idx = 
              val argToCode: Code = for((arg,argIndex) <- args.zipWithIndex) yield {
                GetLocal(memAddr) <:>
                  Const(4*argIndex+4) <:>
                  Add <:>
                  cgExpr(arg) <:>
                  Store
              }
              //doing global
              GetGlobal(Utils.memoryBoundary) <:> 
              SetLocal(memAddr) <:>
              GetGlobal(Utils.memoryBoundary) <:> 
              Const(4 * (args.size + 1)) <:> 
              Add <:>
              SetGlobal(Utils.memoryBoundary) <:> 
              //로컬을 불러옴
              GetLocal(memAddr) <:> 
              Const(sig.index) <:>
              Store <:> 
              argToCode <:>
              GetLocal(memAddr)
            }
            case None =>{
              args.map(arg => cgExpr(arg)) <:> Call(Utils.fullName(table.getFunction(qname).get.owner, qname))
            }
          }
        }
        
        case Match(scrut, cases) =>{

          // Checks if a value matches a pattern.
          // Assumes value is on top of stack (and CONSUMES it)
          // Returns the code to check the value, and a map of bindings.
          def matchAndBind(pat: Pattern): (Code, Map[Identifier, Int]) = pat match {
            case IdPattern(id) =>
              val idLocal = lh.getFreshLocal()
              (Comment(pat.toString) <:> 
              // Assign val to id.
              SetLocal(idLocal) <:> 
              // Return true (IdPattern always matches).
              Const(1),
              // Let the code generation of the expression which corresponds to this pattern
              // know that the bound id is at local idLocal.
              Map(id -> idLocal))

            case LiteralPattern(lit) => 
              // val litLocal = lh.getFreshLocal()
              (Comment(pat.toString) <:> cgExpr(lit) <:> Eq, Map())
            case CaseClassPattern(constr, args) =>
              
              val constrIndex = lh.getFreshLocal()
              var localMap: Map[Identifier, Int] = Map()
              val newCode = args.zipWithIndex.map{
                case(a, i) =>
                  val (code, addedLocals) = matchAndBind(a)
                  localMap = localMap ++ addedLocals
                  GetLocal(constrIndex) <:>
                  adtField(i) <:>
                  Load <:>
                  code
              }
              val originalIndex = table.getConstructor(constr).get.index
              // val newLocal = locals ++ newCode.map(_._2).foldLeft(Map[Identifier,
                    // Int]())((lhs: Map[Identifier, Int], rhs: Map[Identifier, Int]) => lhs ++ rhs)
              // val newLocal =  newCode.map(_._2).foldLeft(Map[Identifier,
              //       Int]())((lhs: Map[Identifier, Int], rhs: Map[Identifier, Int]) => lhs ++ rhs)
              
              // if(args.isEmpty){
              //    (Comment(pat.toString) <:>
              //     SetLocal(constrIndex) <:>
              //     GetLocal(constrIndex) <:>
              //     Load <:>
              //     Const(originalIndex) <:>
              //     Eq <:>
              //     If_i32 <:>
              //     Const(1) <:>
              //     Else <:> Const(0) <:> End, newLocal)
              // } else if(args.lengthCompare(1) == 0){
              //   (Comment(pat.toString) <:>
              //     SetLocal(constrIndex) <:>
              //     GetLocal(constrIndex) <:>
              //     Load <:>
              //     Const(originalIndex) <:>
              //     Eq <:>
              //     If_i32 <:>
              //     newCode.map(_._1) <:>
                  
              //     Else <:> Const(0) <:> End, newLocal)
              // } else {
              //   (Comment(pat.toString) <:>
              //     SetLocal(constrIndex) <:>
              //     GetLocal(constrIndex) <:>
              //     Load <:>
              //     Const(originalIndex) <:>
              //     Eq <:>
              //     If_i32 <:>
              //     newCode.map(_._1) <:>
              //     args.tail.map(indArg => And) <:>
              //     Else <:> Const(0) <:> End, newLocal)
              // }
              (SetLocal(constrIndex) <:>
              GetLocal(constrIndex) <:>
              Load <:>
              Const(originalIndex) <:>
              Eq <:>
              newCode <:>
              List.fill(args.size)(And), localMap)
              

            case WildcardPattern() => (Comment(pat.toString) <:> Drop <:> Const(1),  Map())
          }
          // val caseMap: List[(MatchCase, (Code, Map[Identifier, Int]))] = cases.map(indCase => (indCase, matchAndBind(indCase.pat)))
          val newLocal = lh.getFreshLocal()
          def caseCode(list: List[MatchCase]):Code = {
            list match {
              
            case first::second =>
            val (code, add) = matchAndBind(first.pat)
            GetLocal(newLocal) <:>
            code <:>
            If_i32 <:>
            cgExpr(first.expr)(locals++add, lh) <:> 
            Else   <:> caseCode(second) <:> End

            case Nil => mkString("wtf else") <:> Call("Std_printString") <:> Unreachable
            }
          } 
          //in the end
          
          cgExpr(scrut) <:> SetLocal(newLocal) <:> caseCode(cases) 
          // <:> mkString("wtf else") <:> Call("Std_printString")
          // <:> Unreachable
          // <:> End
        }
          
        case Error(e) =>
          cgExpr(StringLiteral("error:")) <:>
            cgExpr(e) <:>
            Call("Std_printString") <:>
            Instructions.Unreachable

      }
    }
    
    Module(
      program.modules.last.name.name,
      defaultImports,
      globalsNo,
      wasmFunctions ++ (program.modules flatMap cgModule)
    )

  }
}
